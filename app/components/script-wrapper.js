import Component from '@glimmer/component';
import { action } from '@ember/object';
import { tracked } from '@glimmer/tracking';
import { inject as service } from '@ember/service';
import { use } from 'ember-usable';
import { useMachine, matchesState } from 'ember-statecharts';
import scriptWrapperMachine from '../machines/script-wrapper-machine';
import { isPresent } from '@ember/utils';

export default class ScriptWrapperComponent extends Component {
  @service store;
  @tracked editorLineCount;

  @use statechart = useMachine(scriptWrapperMachine).withConfig({
    guards: {
      canShowInit: this._initModelPresent.bind(this),
      canShowOnstep: this._onstepModelPresent.bind(this),
    },
  });

  @matchesState('presets')
  showPresets;

  @matchesState('signalGui')
  showSignalGui;

  @matchesState('script')
  showScripts;

  @matchesState({ script: 'init' })
  showInitScript;

  @matchesState({ script: 'onstep' })
  showOnstepScript;

  /*
    state machine actions
  */
  @action
  openGUI() {
    this.statechart.send('OPEN_GUI');
  }

  @action
  async createScriptFromGUI(scriptModel) {
    scriptModel = await scriptModel; // convert proxy to actual model
    if (scriptModel.get('signalChainGeneratedCode')) {
      await scriptModel.get('updateScriptTask').perform('editorContent', scriptModel.signalChainGeneratedCode);
      await scriptModel.get('runCode').perform();
    }
    this.statechart.send('CREATE_FROM_GUI');
  }

  @action
  cancelGUI() {
    this.statechart.send('CANCEL_GUI');
  }

  @action
  setUITypeTab(selectedTab) {
    this.statechart.send(`SET_TAB_${(selectedTab.toUpperCase())}`);
  }
  
  @action
  setScriptTypeTab(selectedTab) {
    this.statechart.send(`SET_TAB_${(selectedTab.toUpperCase())}`);
  }

  /*
    state machine guards
  */
  _initModelPresent() {
    return isPresent(this.args.track.initScript);
  }

  _onstepModelPresent() {
    return isPresent(this.args.track.onstepScript);
  }
  

  // since the script wrapper is only rendered once on the project level
  // dynamically update the preset menu to a value saved on the track
  // when the track changes
  setDefaultPreset(presetMenu, [selectedOptionIdx]) {
    presetMenu.selectedIndex = selectedOptionIdx;
  }

  // TODO: replace this with a global helper/util
  // for setting a property on a model record?
  @action
  updateSignalChain(scriptModel, content) {
    // signalChainGeneratedCode is a temporary property, not persisted to the database
    // used to store the code generated by the signal chain UI temporarily before saving
    // scriptModeland invoking it
    // REFACTOR: instead of saving the rendered code as signalChainGeneratedCode, 
    // this could instead save the SignalChainCreator node arrays, then render them as code upon clicking Submit
    // this would allow us to save the UI state of the signal chain after a user submits it
    scriptModel.get('updateScriptTask').perform('signalChainGeneratedCode', content);
  }

  @action
  async selectPreset({ target }) {
    const presetId = target.value;

    // save the selection on the track model so the dropdown updates when changing tracks\
    this.args.track.selectedPreset = presetId;
    // fetch the full preset record (with related script models)
    const preset = await this.store.findRecord('preset', presetId);
    preset.applyToTrack.perform(this.args.track);
  }
}
